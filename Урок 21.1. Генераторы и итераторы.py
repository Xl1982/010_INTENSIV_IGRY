class MyNumbers:
    def __iter__(self):
        self.a = 1
        return self

    def __next__(self):
        if self.a <= 4:
            x = self.a
            self.a += 1
            return x
        else:
            raise StopIteration


myclass = MyNumbers()
myiter = iter(myclass)

print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))







# a = ('Раис', "Anton", "Vlada")
# iterator = iter(a)
# for x in a:
#     print(x)



"""Методические
указания
Урок
21.1.Генераторы
и
итераторы
Задачи
урока:
Генераторы
и
итераторы

0.
Подготовка
к
уроку

До
начала
урока
преподавателю
необходимо:
Просмотреть, как
ученики
справились
с
домашним
заданием
Прочитать
методичку

1.
Рекурсивные
генераторы
Учитель: Генераторы
могут
быть
рекурсивными, как
любая
другая
функция.
Рекурсия — это
функция, которая
вызывает
саму
себя, но
с
другими
значениями
параметров.
Напишем
генератор
перестановок
элементов
в
списке.Логика
генератора: функция
перемещает
каждый
элемент
списка
на
первое
место, заменяя
его
первым
элементом
в
списке.


def func_gen(items):
    if len(items) == 0:
        yield []
    else:
        pi = items[:]
        for i in range(len(pi)):
            pi[0], pi[i] = pi[i], pi[0]
            for p in func_gen(pi[1:]):
                yield [pi[0]] + p


for p in func_gen([1, 2, 3]):
    print(p)

2.
Итераторы.
Итератор(iterator) - это
объект, который
возвращает
свои
элементы
по
одному
за
раз.С
точки
зрения
Python - это
любой
объект(экземпляр
класса), у
которого
есть
метод
__next__.Этот
метод
возвращает
следующий
элемент, если
он
есть, или
возвращает
исключение
StopIteration, когда
элементы
закончились.Кроме
того, итератор
запоминает, на
каком
объекте
он
остановился
в
последнюю
итерацию.

Коллекции, строки — это
все
итерируемые
объекты.Они
являются
итерируемыми
контейнерами, из
которых
вы
можете
получить
итератор.Все
эти
объекты
имеют
метод
iter(), который
используется
для
получения
итератора.
Обратите
внимание, что
итерируемый
объект
не
обязательно
является
итератором.Поскольку
на
самом
деле
сам
по
себе
он
не
выполняет
итерацию.У
вас
может
быть
отдельный
объект - итератор, который
возвращается
из
итерируемого
класса, а
не
класс, обрабатывающий
свою
собственную
итерацию.

Получим
итератор
из
строки
и
выведем
каждое
значение

a = 'hello'
iterator = iter(a)
print(next(iterator))
print(next(iterator))
print(next(iterator))
print(next(iterator))
print(next(iterator))
print(next(iterator))

Когда
мы
перебрали
весь
объект, то
на
следующей
итерации
мы
видим
исключение
StopIteration.

Также
получим
итератор
из
кортежа

tuple1 = ("яблоко", "банан", "вишня")
myit = iter(tuple1)
print(next(myit))
print(next(myit))
print(next(myit))

Мы
также
можем
использовать
цикл
for для итерации по итерируему объект.

tuple1 = ("яблоко", "банан", "вишня")
for x in tuple1:
    print(x)

Учитель: Теперь
давайте
разберемся
как
создать
свой
класс
итератора.Чтобы
создать
объект / класс
в
качестве
итератора, вам
необходимо
реализовать
методы
__iter__()
и
__next__()
для
объекта.

Как
мы
знаем
из
ООП, у
всех
классов
есть
функция
под
названием
__init__(), которая
позволяет
вам
делать
инициализацию
при
создании
объекта.
Метод
__iter__()
действует
аналогично, вы
можете
выполнять
операции(инициализацию
и
т.д), Но
всегда
должны
возвращать
сам
объект
итератора.
Метод
__next
__()
также
позволяет
вам
выполнять
операции
и
должен
возвращать
следующий
элемент
в
последовательности.
Создадим
итератор, который
возвращает
числа, начиная
с
1, и
увеличивает
на
единицу(возвращая
1, 2, 3, 4, 5
и
т.д.):

class MyNumbers:
    def __iter__(self):
        self.a = 1
        return self

    def __next__(self):
        x = self.a
        self.a += 1
        return x


myclass = MyNumbers()
myiter = iter(myclass)
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))

Данный
пример
будет
продолжаться
вечно, пока
вы
вызываем
оператор
next()
или
если
используем
в
цикле
for .Чтобы итерация не продолжалась вечно, мы можем использовать оператор StopIteration.

В
метод
__next
__()
мы
можем
добавить
условие
завершения, чтобы
вызвать
ошибку, если
итерация
выполняется
указанное
количество
раз:


class MyNumbers:
    def __iter__(self):
        self.a = 1
        return self

    def __next__(self):
        if self.a <= 20:
            x = self.a
            self.a += 1
            return x
        else:
            raise StopIteration


myclass = MyNumbers()
myiter = iter(myclass)
for x in myiter:
    print(x)

Исходя
из
данного
примера
сделаем
небольшой
вывод: Если
экземпляр
obj
поддерживает
перебор, он
предоставляет
метод
obj.__iter__(), возвращающий
итератор.Итератор
iter
реализует
один
метод
iter.__next__(), который
возвращает
следующий
объект
или
выдает
исключение
StopIteration
для
обозначения
конца
перебора.Эти
методы
используются
реализацией
команды
for и другими операциями, которые неявно выполняют перебор.

Объект
может
дополнительно
предоставить
обратный
итератор, если
он
реализует
специальный
метод
__reversed__().Он
должен
возвращать
объект
итератора
с
таким
же
интерфейсом, как
у
обычного(то
есть
методом
__next__(), выдающим
StopIteration
в
конце
перебора).Этот
метод
используется
встроенной
функцией
reversed().
for i in reversed([1, 2, 3]):
    print(i)

Результат
3
2
1

В
стандартной
реализации
перебора
используется
функция - генератор, связанная
с
yield


class MyClass:
    def __init__(self, start, stop, step):
        self.start = start
        self.stop = stop
        self.step = step

    def __iter__(self):
        x = self.start
        while x < self.stop:
            yield x
            x += self.step


nums = MyClass(0.0, 1.0, 0.1)
for x in nums:
    print(x)

Итерируемый
объект — это
объект
с
методом
__iter__, который
возвращает
итератор.
Итератор — это
объект
с
методом
__iter__, который
возвращает
самого
себя, и
методом
__next__, который
возвращает
следующий
элемент.
Итераторы
также
являются
итерируемыми
объектами.Однако
они “исчерпываются”, а
итерируемые
объекты — нет.

3.
Решение
задач
Задача
1
Дан
словарь
с
числовыми
значениями.Необходимо
их
все
перемножить
и
вывести
на
экран

Решение

my_dictionary = {'data1': 375, 'data2': 567, 'data3': -37, 'data4': 21}
result = 1
for key in my_dictionary:
    result = result * my_dictionary[key]
print(result)

Задача
2
Создайте
словарь
из
строки
'python'
следующим
образом: в
качестве
ключей
возьмите
буквы
строки, а
значениями
пусть
будут
числа, соответствующие
количеству
вхождений
данной
буквы
в
строку.

str1 = 'pythonist'
my_dict = {i: str1.count(i) for i in str1}
print(my_dict)

Дополнительно
Если
на
уроке
остается
время, то
ученикам
можно
предложить
начать
прорешивать
домашнее
задание.

Домашняя
работа
Задача
1
Написать
выражение - генератор, возводящее в
куб
числа
от
1
до
10
включительно.
Вывести
все
значение
в
виде
списка
"""