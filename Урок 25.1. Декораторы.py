def check_health(func):
    def wrapper(player, *args, **kwargs):
        if player.health > 50:
            return func(player, *args, **kwargs)
        else:
            print(f'{player1.name}, ваш уровень здоровья недостаточен для атаки')
            return None
    return wrapper

class Player:
    def __init__(self, name):
        self.name = name
        self.health = 100

    @check_health
    def attack(self):
        print(f'{self.name} Атакует')

    def take_damage(self, damage):
        self.health -= damage
        print(f'{self.name}получает урон! Здоровье: {self.health}')

player1 = Player("Амир")
player1.attack()
player1.take_damage(33)
player1.take_damage(33)
player1.attack()




















"""from functools import wraps
def decor(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(func.__name__)
        return func(*args, **kwargs)
    return wrapper

@decor
def func(a, b):
    return a + b


print(func(1, 5))
print(func.__name__)
print(func.__doc__)
"""
"""Методические
указания
Урок
25.1.Декораторы
Задачи
урока:
Декораторы

0.
Подготовка
к
уроку

До
начала
урока
преподавателю
необходимо:
Просмотреть, как
ученики
справились
с
домашним
заданием
Прочитать
методичку

1.
Модуль
functools
Учитель: Сегодня
мы
с
вами
познакомимся
с
модулем
functools.Functools - сборник
различных
функций
взаимодействующих
с
другими
функциями.Данный
модуль
предоставляет
нам
различные
декораторы
для
кэширования, а
также
для
передачи
различных
данных
от
нашей
функции
декоратору.Например
имя
функции
или
ее
строку
документации.Давайте
рассмотрим
небольшой
пример.Создадим
декоратор, который
выводит
имя
функции
перед
ее
вызовом


def decor(func):
    def wrapper(*args, **kwargs):
        print(func.__name__)
        return func(*args, **kwargs)

    return wrapper


Также
создадим
простую
функцию, которая
возвращает
результат
сложения
двух
чисел





Вызовем
функцию, а
также
попробуем
вывести
ее
имя
и
строку
документации
print(func(1, 5))
print(func.__name__)
print(func.__doc__)

Результат
6
func
Функция
возвращает
сложение
двух
чисел

Отлично.Теперь
декорируем
функцию
и
попробуем
еще
раз
вывести
все
те
же
данные


@decor
def func(a, b):
    return a + b


Результат
func
6
wrapper
None

Как
мы
видим
имя
функции
изменилось
на
имя
обертки, а
строка
документации
не
была
найдена.Декоратор
wraps
поможет
решить
данную
проблему


def decor(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(func.__name__)
        return func(*args, **kwargs)

    return wrapper


Результат
func
6
func
Функция
возврощает
сложение
двух
чисел

В
данном
примере, мы
видим, что
декорируется
именно
внутренняя
функция
wrapper
нашего
декоратора.Применяя
этот
декоратор
wraps
к
нашей
внутренней
функции, мы
копируем
имя, строку
документации
и
сигнатуру
функции
в
нашу
внутреннюю
функцию.

Отлично
давайте
рассмотрим
еще
один
декоратор
который
может
помочь
при
каких
то
больших
и
длительных
операциях.Это
декоратор @ cache.Он
позволяет
кэшировать, т.е
временно
сохранить
результат, для
быстрого
доступа
к
нему.
Напишем
простую, но
очень
длительную
по
времени
выполнения
функцию


def func(n):
    result = 0
    for i in range(n):
        result += i
    return result


Вызовем
функцию
и
измерим
время
ее
выполнения.
start1 = time.time()
print(func(100000000))
end1 = time.time()
print(end1 - start1)

Результат
4999999950000000
4.100029945373535

Теперь
декорируем
нашу
функцию
from functools import cache


@cache
def func(n):
    result = 0
    for i in range(n):
        result += i
    return result


И
добавим
еще
один
вызов
функции
с
теми
же
аргументами
и
измерим
время
start1 = time.time()
print(func(100000000))
end1 = time.time()
print(end1 - start1)
start2 = time.time()
print(func(100000000))
end2 = time.time()
print(end2 - start2)

Результат
4999999950000000
4.079029560089111
4999999950000000
0.0

Как
мы
видим
второй
раз
функцию
выполняется
мгновенно.Все
благодаря
декоратору
cache.В
данном
случае
нам
уже
не
требуется
тратить
ресурсы
на
вычисление, а
мы
можем
получить
его
из
кэша.Если
же
аргументы
будут
разными, то
все
результаты
будут
вычисляться
отдельно.
start1 = time.time()
print(func(100000000))
end1 = time.time()
print(end1 - start1)
start2 = time.time()
print(func(100000001))
end2 = time.time()
print(end2 - start2)

Результат
4999999950000000
4.087999582290649
5000000050000000
4.065028429031372

Мы
с
вами
рассмотрели
два
очень
интересных
декоратора
из
модуля
functools, но
стоит
понимать, что
это
не
все, что
может
нам
предоставить
данный
модуль.

2.
Обработка
исключений(Доп.тема)
Учитель: Давайте
научимся
обрабатывать
возможные
ошибки
не
с
помощью
условий, а
с
помощью
специальных
операторов
предназначенных
для
этого.
В
Python
исключения
обрабатываются
с
помощью
блоков
try/ except.Для этого операция, которая может вызвать исключение, помещается внутрь блока try.А код, который должен быть выполнен при возникновении ошибки, находиться внутри except.

Исключения(exceptions) - ещё
один
тип
данных
в
python.Исключения
необходимы
для
того, чтобы
сообщать
программисту
об
ошибках.
Самый
простейший
пример
исключения - деление
на
ноль, с
которым
мы
встречались
в
калькуляторе

print(100 / 0)

Результат
Traceback(most
recent
call
last):
File
"", line
1, in
print(100 / 0)
ZeroDivisionError: division
by
zero

Разберём
это
сообщение
подробнее: интерпретатор
нам
сообщает
о
том, что
он
поймал
исключение
и
напечатал
информацию(Traceback(most
recent
call
last)).
Далее
имя
файла(File
"").Имя
пустое, потому
что
мы
находимся
в
интерактивном
режиме, строка
в
файле(line
1);
Выражение, в
котором
произошла
ошибка(100 / 0).
Название
исключения(ZeroDivisionError)
и
краткое
описание
исключения(division
by
zero).
Разумеется, возможны
и
другие
исключения:

print(2 + '1')
Traceback(most
recent
call
last):
File
"", line
1, in
print(2 + '1')
TypeError: unsupported
operand
type(s)
for +: 'int' and 'str'

print(int('qwerty'))
Traceback(most
recent
call
last):
File
"", line
1, in
print(int('qwerty'))
ValueError: invalid
literal
for int() with base 10: 'qwerty'

В
этих
двух
примерах
генерируются
исключения
TypeError
и
ValueError
соответственно.Подсказки
дают
нам
полную
информацию
о
том, где
порождено
исключение, и
с
чем
оно
связано.
Рассмотрим
иерархию
встроенных
в
python
исключений, хотя
иногда
вам
могут
встретиться
и
другие, так
как
программисты
могут
создавать
собственные
исключения.

BaseException - базовое
исключение, от
которого
берут
начало
все
остальные.
SystemExit - исключение, порождаемое
функцией
sys.exit
при
выходе
из
программы.
KeyboardInterrupt - порождается
при
прерывании
программы
пользователем(обычно
сочетанием
клавиш
Ctrl + C).
GeneratorExit - порождается
при
вызове
метода
close
объекта
generator.
Exception - а
вот
тут
уже
заканчиваются
полностью
системные
исключения(которые
лучше
не
трогать) и
начинаются
обыкновенные, с
которыми
можно
работать.
StopIteration - порождается
встроенной
функцией
next, если
в
итераторе
больше
нет
элементов.
ArithmeticError - арифметическая
ошибка.
FloatingPointError - порождается
при
неудачном
выполнении
операции
с
плавающей
запятой.На
практике
встречается
нечасто.
OverflowError - возникает, когда
результат
арифметической
операции
слишком
велик
для
представления.Не
появляется
при
обычной
работе
с
целыми
числами(так
как
python
поддерживает
длинные
числа), но
может
возникать
в
некоторых
других
случаях.
ZeroDivisionError - деление
на
ноль.
AssertionError - выражение
в
функции
assert ложно.
AttributeError - объект
не
имеет
данного
атрибута(значения
или
метода).
BufferError - операция, связанная
с
буфером, не
может
быть
выполнена.
EOFError - функция
наткнулась
на
конец
файла
и
не
смогла
прочитать
то, что
хотела.
ImportError - не
удалось
импортирование
модуля
или
его
атрибута.
LookupError - некорректный
индекс
или
ключ.
IndexError - индекс
не
входит
в
диапазон
элементов.
KeyError - несуществующий
ключ(в
словаре, множестве
или
другом
объекте).
MemoryError - недостаточно
памяти.
NameError - не
найдено
переменной
с
таким
именем.
UnboundLocalError - сделана
ссылка
на
локальную
переменную
в
функции, но
переменная
не
определена
ранее.
OSError - ошибка, связанная
с
системой.
BlockingIOError
ChildProcessError - неудача
при
операции
с
дочерним
процессом.
ConnectionError - базовый
класс
для
исключений, связанных
с
подключениями.
BrokenPipeError
ConnectionAbortedError
ConnectionRefusedError
ConnectionResetError
FileExistsError - попытка
создания
файла
или
директории, которая
уже
существует.
FileNotFoundError - файл
или
директория
не
существует.
InterruptedError - системный
вызов
прерван
входящим
сигналом.
IsADirectoryError - ожидался
файл, но
это
директория.
NotADirectoryError - ожидалась
директория, но
это
файл.
PermissionError - не
хватает
прав
доступа.
ProcessLookupError - указанного
процесса
не
существует.
TimeoutError - закончилось
время
ожидания.
ReferenceError - попытка
доступа
к
атрибуту
со
слабой
ссылкой.
RuntimeError - возникает, когда
исключение
не
попадает
ни
под
одну
из
других
категорий.
NotImplementedError - возникает, когда
абстрактные
методы
класса
требуют
переопределения
в
дочерних
классах.
SyntaxError - синтаксическая
ошибка.
IndentationError - неправильные
отступы.
TabError - смешивание
в
отступах
табуляции
и
пробелов.
SystemError - внутренняя
ошибка.
TypeError - операция
применена
к
объекту
несоответствующего
типа.
ValueError - функция
получает
аргумент
правильного
типа, но
некорректного
значения.
UnicodeError - ошибка, связанная
с
кодированием / раскодированием
unicode
в
строках.
UnicodeEncodeError - исключение, связанное
с
кодированием
unicode.
UnicodeDecodeError - исключение, связанное
с
декодированием
unicode.
UnicodeTranslateError - исключение, связанное
с
переводом
unicode.
Warning - предупреждение.
Теперь, зная, когда
и
при
каких
обстоятельствах
могут
возникнуть
исключения, мы
можем
их
обрабатывать.Для
обработки
исключений
используется
конструкция
try - except.

try:
    k = 1 / 0
except ZeroDivisionError:
    k = 0

print(k)

В
блоке
try мы выполняем инструкцию, которая может породить исключение, а в блоке except мы перехватываем их.При этом перехватываются как само исключение, так и его потомки.

Также
возможна
инструкция except без
аргументов, которая
перехватывает
вообще
всё(и
прерывание
с
клавиатуры, и
системный
выход
и
т.д.).Поэтому
в
такой
форме
инструкция except практически
не
используется, а
используется except Exception.Однако
чаще
всего
перехватывают
исключения
по
одному, для
упрощения
отладки(вдруг
вы
ещё
другую
ошибку
сделаете, а except её
перехватит).
Ещё
две
инструкции, относящиеся
к
нашей
проблеме, это finally и else.Finally
выполняет
блок
инструкций
в
любом
случае, было
ли
исключение, или
нет(применима, когда
нужно
непременно
что - то
сделать, к
примеру, закрыть
файл).Инструкция else выполняется
в
том
случае, если
исключения
не
было.

f = open('1.txt')
ints = []
try:
    for line in f:
        ints.append(int(line))
except ValueError:
    print('Это не число. Выходим.')
except Exception:
    print('Это что ещё такое?')
else:
    print('Всё хорошо.')
finally:
    f.close()
    print('Я закрыл файл.')

2.
Решение
задач
Задача
1
Написать
функцию
date, принимающую
3
аргумента — день, месяц
и
год.Вернуть
True, если
такая
дата
есть
в
нашем
календаре, и
False
иначе.При
написании
использовать
исключения

Решение

from datetime import date


def check_date(y, m, d):
    try:
        date(y, m, d)
        return True
    except:
        return False


print(check_date(2018, 2, 28))
print(check_date(2018, 2, 29))

Задача
2
Даны
две
различные
клетки
шахматной
доски.Напишите
программу, которая
определяет, может
ли
ладья
попасть
с
первой
клетки
на
вторую
одним
ходом.Программа
получает
на
вход
четыре
числа
от
1
до
8
каждое, задающие
номер
столбца
и
номер
строки
сначала
для
первой
клетки, потом
для
второй
клетки.Программа
должна
вывести «YES», если
из
первой
клетки
ходом
ладьи
можно
попасть
во
вторую, или «NO» в
противном
случае.

Решение

a1 = int(input())
a2 = int(input())
a3 = int(input())
a4 = int(input())
print('YES') if (a1 == a3) or (a2 == a4) else print('NO')

Дополнительно
Если
на
уроке
остается
время, то
ученикам
можно
предложить
начать
прорешивать
домашнее
задание.

Домашняя
работа
Задача
1.
Реализовать
программу, которая
рассчитывает
площадь
и
периметр
прямоугольника
и
обработать
все
возможное
ошибки
с
помощью
try..except

"""